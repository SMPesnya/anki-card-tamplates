<!-- По изображению нужно ввести английское слово, наобратной стороне сравнение по буквам, воспроизведение, трансктрипция, перевод и заметки -->
<div class="image-wrap image-random">
 {{Image}}
</div>

<div class="prompt">Введите слово:</div>
<div class="type">{{type:Word}}</div>

<script>
(function () {
  function pickRandomImage() {
    // если на карточке несколько таких контейнеров — обработаем все
    document.querySelectorAll('.image-random').forEach(container => {
      const imgs = container.querySelectorAll('img');
      if (imgs.length > 1) {
        imgs.forEach(img => img.style.display = 'none');
        imgs[Math.floor(Math.random() * imgs.length)].style.display = 'block';
      }
    });
  }

   // Нормализация: нижний регистр + схлопывание пробелов + trim
  function normalize(s){
    return (s || "")
      .normalize("NFC")
      .toLowerCase()
      .replace(/\s+/g, " ")
      .trim();
  }

  function __init(){
    const el = document.getElementById("typeans");
    // На лицевой стороне это INPUT; на обороте #typeans — уже разметка ответа.
    if (!el || el.tagName.toLowerCase() !== "input") return;

    // Отключим автокапс и автокоррект на мобилках
    el.setAttribute("autocapitalize", "off");
    el.setAttribute("autocorrect", "off");
    el.setAttribute("spellcheck", "false");

    const update = () => {
      const v = normalize(el.value);
      if (el.value !== v) {
        const start = el.selectionStart, end = el.selectionEnd;
        el.value = v;
        try { el.setSelectionRange(start, end); } catch (_) { /* ok */ }
      }
    };

    el.addEventListener("input", update, { passive: true });
    el.addEventListener("change", update);
    // на всякий случай — привести сразу после рендера
    setTimeout(update, 0);
  }
	
  function init(){
    __init();
    pickRandomImage();
  }

  // если DOM уже готов — запускаем сразу; иначе ждём
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // на всякий случай — ещё один тик после рендеринга
  setTimeout(init, 0);
})();
</script>


